<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ... (keep the existing head content) ... -->
    <meta charset="UTF-8">
    <title>Webcam Fullscreen with Object Detection and FPS</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        /* ... (keep the existing styles) ... */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            background: black;
        }
        #videoElement {
            width: 100vw;
            height: 100vh;
            object-fit: cover;
        }
        #sliderContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #brightnessSlider {
            width: 150px;
        }
        label {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #messageContainer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 400px;
        }
        .message {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: black;
            opacity: 1;
            transition: opacity 1s ease-out;
            position: absolute;
            /* width: 280px; /* Fixed width for each message */
            /* height: 40px; */
            /* box-sizing: border-box; */
        }
        /* ... (keep other existing styles) ... */
        #detectionCanvas {
            position: absolute;
            top: 10px;
            left: 10px;
            border: 2px solid white;
        }
        #fullscreenCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- ... (keep the existing body content) ... -->
    <div id="sliderContainer">
        <label for="brightnessSlider">Brightness</label>
        <input type="range" id="brightnessSlider" min="0" max="200" value="100">
    </div>
    <div id="messageContainer"></div>
    <video id="videoElement" autoplay></video>
    <canvas id="detectionCanvas" width="320" height="240"></canvas>
    <canvas id="fullscreenCanvas"></canvas>
     

    <script>
        // ... (keep other existing functions) ...
        let videoElement, detectionCanvas, detectionCtx, fullscreenCanvas, fullscreenCtx;
        let lastDetectionTime = 0, lastFullscreenTime = 0;
        let detectionFPS = 0, fullscreenFPS = 0;

        async function setupWebcam() {
            videoElement = document.getElementById("videoElement");
            const constraints = {
                video: {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    facingMode: "environment"
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                await videoElement.play();
            } catch (err) {
                console.error("Error accessing webcam:", err);
            }
        }

        function setupBrightnessSlider() {
            const slider = document.getElementById("brightnessSlider");
            slider.addEventListener("input", () => {
                const brightnessValue = slider.value;
                videoElement.style.filter = `brightness(${brightnessValue}%)`;
            });
        }


        async function setupObjectDetection() {
            // ... (keep existing setup code) ...
            detectionCanvas = document.getElementById("detectionCanvas");
            detectionCtx = detectionCanvas.getContext("2d");

            fullscreenCanvas = document.getElementById("fullscreenCanvas");
            fullscreenCtx = fullscreenCanvas.getContext("2d");
            resizeFullscreenCanvas();
            window.addEventListener('resize', resizeFullscreenCanvas);

            const model = await ort.InferenceSession.create("yolov8n.onnx");


            async function detectObjects() {
                const now = performance.now();
                detectionFPS = 1000 / (now - lastDetectionTime);
                lastDetectionTime = now;

                const [input, img_width, img_height] = await prepare_input(videoElement);
                const output = await run_model(model, input);
                const boxes = process_output(output, img_width, img_height);
                drawDetections(boxes);
                
                // Display detected objects in message
                if (boxes.length > 0) {
                    showDetectionMessage(boxes);
                }
                
                requestAnimationFrame(detectObjects);
            }

            // ... (keep other existing functions) ...
            function updateFullscreenFPS() {
                const now = performance.now();
                fullscreenFPS = 1000 / (now - lastFullscreenTime);
                lastFullscreenTime = now;

                fullscreenCtx.clearRect(0, 0, fullscreenCanvas.width, fullscreenCanvas.height);
                fullscreenCtx.font = "24px Arial";
                fullscreenCtx.fillStyle = "yellow";
                fullscreenCtx.fillText(`Full Screen FPS: ${fullscreenFPS.toFixed(2)}`,fullscreenCanvas.width/2 , 30);

                requestAnimationFrame(updateFullscreenFPS);
            }
            

            detectObjects();
            updateFullscreenFPS();
        }

        // function showDetectionMessage(label, confidence) {
        //     const messageContainer = document.getElementById("messageContainer");
        //     const message = document.createElement("div");
        //     message.className = "message";
        //     message.textContent = `Detected ${label} with a confidence of ${confidence.toFixed(2)}`;

        //     messageContainer.prepend(message);
        //     updateMessagePositions();

        //     if (messageContainer.children.length > 4) {
        //         const lastChild = messageContainer.lastChild;
        //         lastChild.style.opacity = 0;
        //         setTimeout(() => {
        //             lastChild.remove();
        //         }, 1000);
        //     }
        // }


        // function updateMessagePositions() {
        //     const messages = document.querySelectorAll('.message');
        //     const offsetStep = 20;
        //     const maxVisibleMessages = 4;

        //     messages.forEach((message, index) => {
        //         message.style.bottom = `${(messages.length - 1 - index) * offsetStep}px`;
        //         console.log(messages.length);
        //         console.log(index);
        //         console.log(offsetStep, "\n");
        //         message.style.left = `${10 + (index * 15)}px`;
        //         message.style.zIndex = maxVisibleMessages - index;
        //         message.style.opacity = 1 - (index * 0.3);
        //     });
        // }

        function showDetectionMessage(boxes) {
            const messageContainer = document.getElementById("messageContainer");
            const message = document.createElement("div");
            message.className = "message";

            // Create a message for up to 3 detected objects
            const detectionTexts = boxes.slice(0, 3).map(([,,,,label, prob]) => 
                `${label} (${prob.toFixed(2)})`
            );

            message.innerHTML = `Detected: ${detectionTexts.join(', ')}`;
            if (boxes.length > 3) {
                message.innerHTML += `, and ${boxes.length - 3} more`;
            }

            messageContainer.prepend(message);
            updateMessagePositions();

            // Remove excess messages
            const messages = messageContainer.getElementsByClassName('message');
            while (messages.length > 4) {
                messageContainer.removeChild(messages[messages.length - 1]);
            }
        }

        function updateMessagePositions() {
            const messages = document.querySelectorAll('.message');
            const offsetStep = 20;
            const maxVisibleMessages = 4;

            messages.forEach((message, index) => {
                message.style.bottom = `${(messages.length - 1 - index) * offsetStep}px`;
                message.style.left = `${10 + (index * 15)}px`;
                message.style.zIndex = maxVisibleMessages - index;
                message.style.opacity = 1 - (index * 0.3);
            });
        }

        function resizeFullscreenCanvas() {
            fullscreenCanvas.width = window.innerWidth;
            fullscreenCanvas.height = window.innerHeight;
        }
        async function prepare_input(videoElement) {
            const canvas = document.createElement("canvas");
            canvas.width = 640;
            canvas.height = 640;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(videoElement, 0, 0, 640, 640);
            const imgData = ctx.getImageData(0, 0, 640, 640);
            const pixels = imgData.data;

            const red = [], green = [], blue = [];
            for (let index = 0; index < pixels.length; index += 4) {
                red.push(pixels[index] / 255.0);
                green.push(pixels[index + 1] / 255.0);
                blue.push(pixels[index + 2] / 255.0);
            }
            const input = [...red, ...green, ...blue];
            return [input, videoElement.videoWidth, videoElement.videoHeight];
        }

        async function run_model(model, input) {
            const tensor = new ort.Tensor(Float32Array.from(input), [1, 3, 640, 640]);
            const outputs = await model.run({ images: tensor });
            return outputs["output0"].data;
        }

        function process_output(output, img_width, img_height) {
            let boxes = [];
            for (let index = 0; index < 8400; index++) {
                const [class_id, prob] = [...Array(80).keys()]
                    .map(col => [col, output[8400 * (col + 4) + index]])
                    .reduce((accum, item) => item[1] > accum[1] ? item : accum, [0, 0]);
                if (prob < 0.5) {
                    continue;
                }
                const label = yolo_classes[class_id];
                const xc = output[index];
                const yc = output[8400 + index];
                const w = output[2 * 8400 + index];
                const h = output[3 * 8400 + index];
                const x1 = (xc - w / 2) / 640 * img_width;
                const y1 = (yc - h / 2) / 640 * img_height;
                const x2 = (xc + w / 2) / 640 * img_width;
                const y2 = (yc + h / 2) / 640 * img_height;
                boxes.push([x1, y1, x2, y2, label, prob]);
            }

            boxes = boxes.sort((box1, box2) => box2[5] - box1[5]);
            const result = [];
            while (boxes.length > 0) {
                result.push(boxes[0]);
                boxes = boxes.filter(box => iou(boxes[0], box) < 0.7);
            }
            return result;
        }

        function iou(box1, box2) {
            return intersection(box1, box2) / union(box1, box2);
        }

        function union(box1, box2) {
            const [box1_x1, box1_y1, box1_x2, box1_y2] = box1;
            const [box2_x1, box2_y1, box2_x2, box2_y2] = box2;
            const box1_area = (box1_x2 - box1_x1) * (box1_y2 - box1_y1);
            const box2_area = (box2_x2 - box2_x1) * (box2_y2 - box2_y1);
            return box1_area + box2_area - intersection(box1, box2);
        }

        function intersection(box1, box2) {
            const [box1_x1, box1_y1, box1_x2, box1_y2] = box1;
            const [box2_x1, box2_y1, box2_x2, box2_y2] = box2;
            const x1 = Math.max(box1_x1, box2_x1);
            const y1 = Math.max(box1_y1, box2_y1);
            const x2 = Math.min(box1_x2, box2_x2);
            const y2 = Math.min(box1_y2, box2_y2);
            return (x2 - x1) * (y2 - y1);
        }

        function drawDetections(boxes) {
            detectionCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            detectionCtx.drawImage(videoElement, 0, 0, detectionCanvas.width, detectionCanvas.height);

            detectionCtx.strokeStyle = "#00FF00";
            detectionCtx.lineWidth = 2;
            detectionCtx.font = "12px Arial";

            const scaleX = detectionCanvas.width / videoElement.videoWidth;
            const scaleY = detectionCanvas.height / videoElement.videoHeight;

            boxes.forEach(([x1, y1, x2, y2, label, prob]) => {
                const boxX = x1 * scaleX;
                const boxY = y1 * scaleY;
                const boxWidth = (x2 - x1) * scaleX;
                const boxHeight = (y2 - y1) * scaleY;

                detectionCtx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                detectionCtx.fillStyle = "#00FF00";
                const text = `${label} (${prob.toFixed(2)})`;
                const textWidth = detectionCtx.measureText(text).width;
                detectionCtx.fillRect(boxX, boxY - 20, textWidth + 4, 20);
                detectionCtx.fillStyle = "#000000";
                detectionCtx.fillText(text, boxX + 2, boxY - 5);
            });

            // Draw FPS for detection canvas
            detectionCtx.font = "15px Arial";
            detectionCtx.fillStyle = "green";
            detectionCtx.fillText(`Detection FPS: ${detectionFPS.toFixed(2)}`, detectionCanvas.width/2, 20);
        }

        const yolo_classes = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse',
            'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase',
            'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard',
            'surfboard', 'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant',
            'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
            'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];
        // Remove the setupTimer function as it's no longer needed

        window.onload = async () => {
            await setupWebcam();
            setupBrightnessSlider();
            // Remove setupTimer() call
            await setupObjectDetection();
        };
    </script>
</body>
</html>