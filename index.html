<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Webcam Fullscreen with Object Detection, FPS, and Draggable Elements</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            background: black;
        }
        #videoElement {
            width: 100vw;
            height: 100vh;
            object-fit: cover;
        }
        .draggable {
            position: absolute;
            cursor: move;
        }
        #sliderContainer {
            top: 10px;
            left: calc(100% - 180px); /* Initially position from the left based on its width */
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #brightnessSlider {
            width: 150px;
        }
        label {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #messageContainer {
            bottom: 10px;
            left: 10px;
            width: 400px;
        }
        .message {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: black;
            opacity: 1;
            transition: opacity 1s ease-out;
            position: absolute;
        }
        #detectionCanvas {
            top: 10px;
            left: 10px;
            border: 2px solid white;
        }
        #fullscreenCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="sliderContainer" class="draggable">
        <label for="brightnessSlider">Brightness</label>
        <input type="range" id="brightnessSlider" min="0" max="200" value="100">
    </div>
    <div id="messageContainer" class="draggable"></div>
    <video id="videoElement" autoplay></video>
    <canvas id="detectionCanvas" class="draggable" width="320" height="240"></canvas>
    <canvas id="fullscreenCanvas"></canvas>

    <script>
        // ... (keep all the existing JavaScript code) ...
                // ... (keep other existing functions) ...
        let videoElement, detectionCanvas, detectionCtx, fullscreenCanvas, fullscreenCtx;
        let lastDetectionTime = 0, lastFullscreenTime = 0;
        let detectionFPS = 0, fullscreenFPS = 0;

        async function setupWebcam() {
            videoElement = document.getElementById("videoElement");
            const constraints = {
                video: {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    facingMode: "environment"
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                await videoElement.play();
            } catch (err) {
                console.error("Error accessing webcam:", err);
            }
        }

        function setupBrightnessSlider() {
            const slider = document.getElementById("brightnessSlider");
            slider.addEventListener("input", () => {
                const brightnessValue = slider.value;
                videoElement.style.filter = `brightness(${brightnessValue}%)`;
            });
        }


        async function setupObjectDetection() {
            // ... (keep existing setup code) ...
            detectionCanvas = document.getElementById("detectionCanvas");
            detectionCtx = detectionCanvas.getContext("2d");

            fullscreenCanvas = document.getElementById("fullscreenCanvas");
            fullscreenCtx = fullscreenCanvas.getContext("2d");
            resizeFullscreenCanvas();
            window.addEventListener('resize', resizeFullscreenCanvas);

            const model = await ort.InferenceSession.create("yolov5nu_quant.onnx");
            console.log("yolov5nu_quant.onnx");


            async function detectObjects() {
                const now = performance.now();
                detectionFPS = 1000 / (now - lastDetectionTime);
                lastDetectionTime = now;

                const [input, img_width, img_height] = await prepare_input(videoElement);
                const output = await run_model(model, input);
                const boxes = process_output(output, img_width, img_height);
                drawDetections(boxes);
                
                // Display detected objects in message
                if (boxes.length > 0) {
                    showDetectionMessage(boxes);
                }
                
                requestAnimationFrame(detectObjects);
            }

            // ... (keep other existing functions) ...
            function updateFullscreenFPS() {
                const now = performance.now();
                fullscreenFPS = 1000 / (now - lastFullscreenTime);
                lastFullscreenTime = now;

                fullscreenCtx.clearRect(0, 0, fullscreenCanvas.width, fullscreenCanvas.height);
                fullscreenCtx.font = "24px Arial";
                fullscreenCtx.fillStyle = "yellow";
                fullscreenCtx.fillText(`Full Screen FPS: ${fullscreenFPS.toFixed(2)}`,fullscreenCanvas.width/2 , 30);

                requestAnimationFrame(updateFullscreenFPS);
            }
            

            detectObjects();
            updateFullscreenFPS();
        }

        // function showDetectionMessage(label, confidence) {
        //     const messageContainer = document.getElementById("messageContainer");
        //     const message = document.createElement("div");
        //     message.className = "message";
        //     message.textContent = `Detected ${label} with a confidence of ${confidence.toFixed(2)}`;

        //     messageContainer.prepend(message);
        //     updateMessagePositions();

        //     if (messageContainer.children.length > 4) {
        //         const lastChild = messageContainer.lastChild;
        //         lastChild.style.opacity = 0;
        //         setTimeout(() => {
        //             lastChild.remove();
        //         }, 1000);
        //     }
        // }


        // function updateMessagePositions() {
        //     const messages = document.querySelectorAll('.message');
        //     const offsetStep = 20;
        //     const maxVisibleMessages = 4;

        //     messages.forEach((message, index) => {
        //         message.style.bottom = `${(messages.length - 1 - index) * offsetStep}px`;
        //         console.log(messages.length);
        //         console.log(index);
        //         console.log(offsetStep, "\n");
        //         message.style.left = `${10 + (index * 15)}px`;
        //         message.style.zIndex = maxVisibleMessages - index;
        //         message.style.opacity = 1 - (index * 0.3);
        //     });
        // }

        function showDetectionMessage(boxes) {
            const messageContainer = document.getElementById("messageContainer");
            const message = document.createElement("div");
            message.className = "message";

            // Create a message for up to 3 detected objects
            const detectionTexts = boxes.slice(0, 3).map(([,,,,label, prob]) => 
                `${label} (${prob.toFixed(2)})`
            );

            message.innerHTML = `Detected: ${detectionTexts.join(', ')}`;
            if (boxes.length > 3) {
                message.innerHTML += `, and ${boxes.length - 3} more`;
            }

            messageContainer.prepend(message);
            updateMessagePositions();

            // Remove excess messages
            const messages = messageContainer.getElementsByClassName('message');
            while (messages.length > 4) {
                messageContainer.removeChild(messages[messages.length - 1]);
            }
        }

        function updateMessagePositions() {
            const messages = document.querySelectorAll('.message');
            const offsetStep = 20;
            const maxVisibleMessages = 4;

            messages.forEach((message, index) => {
                message.style.bottom = `${(messages.length - 1 - index) * offsetStep}px`;
                message.style.left = `${10 + (index * 15)}px`;
                message.style.zIndex = maxVisibleMessages - index;
                message.style.opacity = 1 - (index * 0.3);
            });
        }

        function resizeFullscreenCanvas() {
            fullscreenCanvas.width = window.innerWidth;
            fullscreenCanvas.height = window.innerHeight;
        }
        async function prepare_input(videoElement) {
            const canvas = document.createElement("canvas");
            canvas.width = 640;
            canvas.height = 640;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(videoElement, 0, 0, 640, 640);
            const imgData = ctx.getImageData(0, 0, 640, 640);
            const pixels = imgData.data;

            const red = [], green = [], blue = [];
            for (let index = 0; index < pixels.length; index += 4) {
                red.push(pixels[index] / 255.0);
                green.push(pixels[index + 1] / 255.0);
                blue.push(pixels[index + 2] / 255.0);
            }
            const input = [...red, ...green, ...blue];
            return [input, videoElement.videoWidth, videoElement.videoHeight];
        }

        async function run_model(model, input) {
            const tensor = new ort.Tensor(Float32Array.from(input), [1, 3, 640, 640]);
            const outputs = await model.run({ images: tensor });
            return outputs["output0"].data;
        }

        function process_output(output, img_width, img_height) {
            let boxes = [];
            for (let index = 0; index < 8400; index++) {
                const [class_id, prob] = [...Array(80).keys()]
                    .map(col => [col, output[8400 * (col + 4) + index]])
                    .reduce((accum, item) => item[1] > accum[1] ? item : accum, [0, 0]);
                if (prob < 0.5) {
                    continue;
                }
                const label = yolo_classes[class_id];
                const xc = output[index];
                const yc = output[8400 + index];
                const w = output[2 * 8400 + index];
                const h = output[3 * 8400 + index];
                const x1 = (xc - w / 2) / 640 * img_width;
                const y1 = (yc - h / 2) / 640 * img_height;
                const x2 = (xc + w / 2) / 640 * img_width;
                const y2 = (yc + h / 2) / 640 * img_height;
                boxes.push([x1, y1, x2, y2, label, prob]);
            }

            boxes = boxes.sort((box1, box2) => box2[5] - box1[5]);
            const result = [];
            while (boxes.length > 0) {
                result.push(boxes[0]);
                boxes = boxes.filter(box => iou(boxes[0], box) < 0.7);
            }
            return result;
        }

        function iou(box1, box2) {
            return intersection(box1, box2) / union(box1, box2);
        }

        function union(box1, box2) {
            const [box1_x1, box1_y1, box1_x2, box1_y2] = box1;
            const [box2_x1, box2_y1, box2_x2, box2_y2] = box2;
            const box1_area = (box1_x2 - box1_x1) * (box1_y2 - box1_y1);
            const box2_area = (box2_x2 - box2_x1) * (box2_y2 - box2_y1);
            return box1_area + box2_area - intersection(box1, box2);
        }

        function intersection(box1, box2) {
            const [box1_x1, box1_y1, box1_x2, box1_y2] = box1;
            const [box2_x1, box2_y1, box2_x2, box2_y2] = box2;
            const x1 = Math.max(box1_x1, box2_x1);
            const y1 = Math.max(box1_y1, box2_y1);
            const x2 = Math.min(box1_x2, box2_x2);
            const y2 = Math.min(box1_y2, box2_y2);
            return (x2 - x1) * (y2 - y1);
        }

        function drawDetections(boxes) {
            detectionCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            detectionCtx.drawImage(videoElement, 0, 0, detectionCanvas.width, detectionCanvas.height);

            detectionCtx.strokeStyle = "#00FF00";
            detectionCtx.lineWidth = 2;
            detectionCtx.font = "12px Arial";

            const scaleX = detectionCanvas.width / videoElement.videoWidth;
            const scaleY = detectionCanvas.height / videoElement.videoHeight;

            boxes.forEach(([x1, y1, x2, y2, label, prob]) => {
                const boxX = x1 * scaleX;
                const boxY = y1 * scaleY;
                const boxWidth = (x2 - x1) * scaleX;
                const boxHeight = (y2 - y1) * scaleY;

                detectionCtx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                detectionCtx.fillStyle = "#00FF00";
                const text = `${label} (${prob.toFixed(2)})`;
                const textWidth = detectionCtx.measureText(text).width;
                detectionCtx.fillRect(boxX, boxY - 20, textWidth + 4, 20);
                detectionCtx.fillStyle = "#000000";
                detectionCtx.fillText(text, boxX + 2, boxY - 5);
            });

            // Draw FPS for detection canvas
            detectionCtx.font = "15px Arial";
            detectionCtx.fillStyle = "green";
            detectionCtx.fillText(`Detection FPS: ${detectionFPS.toFixed(2)}`, detectionCanvas.width/2, 20);
        }

        const yolo_classes = [
            'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat',
            'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse',
            'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase',
            'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard',
            'surfboard', 'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
            'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant',
            'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven',
            'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
        ];
        // Remove the setupTimer function as it's no longer needed

        // Add this new function for draggable elements
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // Update position based on left and top
                let newTop = element.offsetTop - pos2;
                let newLeft = element.offsetLeft - pos1;
                
                // Ensure the element stays within the viewport
                newTop = Math.max(0, Math.min(window.innerHeight - element.offsetHeight, newTop));
                newLeft = Math.max(0, Math.min(window.innerWidth - element.offsetWidth, newLeft));
                
                element.style.top = newTop + "px";
                element.style.left = newLeft + "px";
                
                // Remove right positioning if it exists
                element.style.right = 'auto';
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        window.onload = async () => {
            await setupWebcam();
            setupBrightnessSlider();
            await setupObjectDetection();

            // Make elements draggable
            const draggableElements = document.querySelectorAll('.draggable');
            draggableElements.forEach(elem => makeDraggable(elem));
        };
    </script>
</body>
</html>
